<!doctype html>
<html>
<head>
	<title>fingerboss</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			background-color: #000000;
		}
	</style>
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black">
	<meta name="apple-mobile-web-app-title" content="Fingerboss">
	<meta name="viewport"
	      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">
	<meta name="viewport" content="minimal-ui">
</head>
<body>
<script src="/pixi.js"></script>
<script src="/socket.io-1.2.0.js"></script>
<script src="/jquery-1.11.1.js"></script>
<script src="/TweenMax.min.js"></script>
<script src="/howler.min.js"></script>
<script>

	window.onerror = function () {
		alert(JSON.stringify(arguments, null, '\t'));
	};
	game();

	function game() {
		var MIN_SIZE = 200 / 800;
		var START_SIZE = 150 / 800;
		var END_SIZE = 500 / 800;
		var GROW_TIME = 6;
		var GROWING_ALPHA = 0.6;
		var UNCONFIRMED_ALPHA = 0.8;
		var CONFIRMED_SIZE_FACTOR = 1/5;
		var SOUND = true;
		var failSound = new Howl({
			urls: ['fail.mp3'],
			volume: 0.3
		});
		var successSound = new Howl({
			urls: ['success.mp3'],
			volume: 0.3
		});
		var socket = io();
		var circles = [];
		var unconfirmedCircles = {};
		var newCircle;
		var color, dt, velocity;
		socket.on('start', function (e) {
			color = e.color;
			dt = Date.now() - e.t;
			velocity = e.velocity;
		});
		var renderer = PIXI.autoDetectRenderer(window.innerWidth, window.innerHeight, {
			backgroundColor: 0x000000,
			antialias: true
		});
		document.body.appendChild(renderer.view);
		$(window).resize(function () {
			renderer.resize(window.innerWidth, window.innerHeight);
			bg.drawRect(0, 0, renderer.view.width, renderer.view.height);
			circles.forEach(function (c) {
				stage.removeChild(c.sprite);
				c.sprite = generateSpriteForCircle(c);
				stage.addChild(c.sprite);
			});
		});
		var stage = new PIXI.Container();
		var bg = getInteraction();
		stage.addChild(bg);
		var touchSprite = new PIXI.Sprite(PIXI.Texture.fromImage('touch.png'));
		touchSprite.anchor.x = 0.5;
		touchSprite.anchor.y = 0.5;
		touchSprite.position.x = renderer.view.width / 2;
		touchSprite.position.y = renderer.view.height / 2;
		touchSprite.alpha = 0.5;
		touchSprite.tl = new TimelineMax({repeat: -1})
				.to(touchSprite, 0.4, {alpha: 1, ease: Power1.easeOut}).
				to(touchSprite, 0.4, {alpha: 0.5, ease: Power1.easeIn});
		stage.addChild(touchSprite);

		function getInteraction() {
			var bg = new PIXI.Graphics();
			bg.interactive = true;
			bg.beginFill(0x000000);
			bg.drawRect(0, 0, renderer.view.width, renderer.view.height);
			bg.interactive = true;
			bg.on('mousedown', onDown);
			bg.on('touchstart', onDown);
			bg.on('mousemove', onMove);
			bg.on('touchmove', onMove);
			bg.on('mouseup', onUp);
			bg.on('touchend', onUp);
			return bg;


			function onDown(e) {
				if (!color) {
					return;
				}
				if (touchSprite) {
					fadeSprite(stage, touchSprite);
					touchSprite = null;
				}
				newCircle = {
					id: Math.random() + '_' + Date.now(),
					x: getX(e),
					y: getY(e),
					size: START_SIZE,
					color: color
				};
				newCircle.tl = new TimelineMax()
						.to(newCircle, GROW_TIME, {size: END_SIZE, ease: Power1.easeOut})
				newCircle.sprite = generateSpriteForCircle(newCircle);
				newCircle.sprite.alpha = GROWING_ALPHA;
				stage.addChild(newCircle.sprite);
			}

			function getX(e) {
				return Math.min(Math.max(e.data.global.x / renderer.view.width, 0), 1);
			}

			function getY(e) {
				return Math.min(Math.max(e.data.global.y / renderer.view.height, 0), 1);
			}

			function onMove(e) {
				if (newCircle) {
					newCircle.x = getX(e);
					newCircle.y = getY(e);
				}
			}

			function onUp() {
				if (newCircle) {
					newCircle.tl.kill();
					delete newCircle.tl;
					delete newCircle._gsTweenID;
					stage.removeChild(newCircle.sprite);
					delete newCircle.sprite;
					if (newCircle.size > MIN_SIZE) {
						newCircle.size *= CONFIRMED_SIZE_FACTOR;
						socket.emit('circle', newCircle);
						newCircle.sprite = generateSpriteForCircle(newCircle);
						newCircle.sprite.alpha = 0.75;
						unconfirmedCircles[newCircle.id] = newCircle;
					} else {
						SOUND && failSound.play();
					}
					newCircle = null;
				}
			}
		}

		function generateSpriteForCircle(c) {
			var gfx = new PIXI.Graphics();
			gfx.beginFill(c.color);
			gfx.drawEllipse(0, 0, 0.2 * renderer.view.width, 0.2 * renderer.view.height);
			var sprite = new PIXI.Sprite(gfx.generateTexture());
			// center the sprite's anchor point
			sprite.anchor.x = 0.5;
			sprite.anchor.y = 0.5;
			sprite.position.x = c.x * renderer.view.width;
			sprite.position.y = c.y * renderer.view.height;
			sprite.width = c.size * renderer.view.width;
			sprite.height = c.size * renderer.view.height;
			return sprite;
		}

		socket.on('circle', function (c) {
			var proposed_dt = Date.now() - c.t;
			var dtDifference = proposed_dt-dt;
			if(Math.abs(dtDifference) > 200){
				dt += 50 * (dtDifference/Math.abs(dtDifference)); //adjust dt a little
			}
			SOUND && successSound.play();
			c.sprite = generateSpriteForCircle(c);
			stage.addChild(c.sprite);
			circles.push(c);
			var uc = unconfirmedCircles[c.id];
			if (uc) {
				stage.removeChild(uc.sprite);
				delete unconfirmedCircles[c.id]
			}
			//collision detection
			var indexesToRemove = [];
			for (var i = 0; i < circles.length - 1; i++) {
				var c1 = circles[i];
				if (!c1 || !c || c1.color === c.color) {
					continue;
				}
				var distance = Math.sqrt(
						Math.pow(Math.abs(c1.x - c.x), 2) +
						Math.pow(Math.abs(getMovedCircleY(c1, c.t) - getMovedCircleY(c, c.t)), 2)
				);
				var minDistance = (c1.size + c.size);
				if (distance < minDistance) {
					killCircleSprite(stage, c1.sprite);
					killCircleSprite(stage, c.sprite);
					indexesToRemove.push(i);
				}
			}
			indexesToRemove.forEach(function (i) {
				delete circles[i];
			});
			circles = circles.filter(Boolean);
			//remove circles out of frame
			circles.forEach(function (c1, i) {
				var y = getMovedCircleY(c1, c.t);
				if (y < -c1.size) {
					delete circles[i];
					stage.removeChild(c1.sprite);
					return;
				}
				c.sprite.position.y = y * renderer.view.height;
			});
			circles = circles.filter(Boolean);

		});
		function getMovedCircleY(c, t) {
			return c.y + (c.t - t) * velocity;
		}

		// start animating
		animate();
		function animate() {
			requestAnimationFrame(animate);
			var t = Date.now() - dt;
			circles.forEach(function (c1) {
				var y = getMovedCircleY(c1, t);
				c1.sprite.position.y = y * renderer.view.height;
			});
			if (newCircle) {
				newCircle.sprite.position.x = newCircle.x * renderer.view.width;
				newCircle.sprite.position.y = newCircle.y * renderer.view.height;
				newCircle.sprite.width = newCircle.size * renderer.view.width;
				newCircle.sprite.height = newCircle.size * renderer.view.height;
				newCircle.sprite.alpha = newCircle.size > MIN_SIZE ? UNCONFIRMED_ALPHA : GROWING_ALPHA;
			}
			// render the container
			renderer.render(stage);
		}
	}
	function killCircleSprite(stage, sprite) {
		new TimelineMax({
			onComplete: function () {
				stage.removeChild(sprite);
			}
		}).to(sprite.scale, 0.5, {x: 0, y: 0});

	}
	function fadeSprite(stage, sprite) {
		new TimelineMax({
			onComplete: function () {
				stage.removeChild(sprite);
				if (sprite.tl) {
					sprite.tl.kill();
				}
			}
		}).to(sprite, 0.3, {alpha: 0});

	}
</script>
</body>
</html>