<!doctype html>
<html>
<head>
	<title>fingerboss</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			background-color: #000000;
		}
	</style>
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black">
	<meta name="apple-mobile-web-app-title" content="Fingerboss">
	<meta name="viewport"
	      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">
	<meta name="viewport" content="minimal-ui">
</head>
<body>
<script src="/pixi.js"></script>
<script src="/socket.io-1.2.0.js"></script>
<script src="/jquery-1.11.1.js"></script>
<script src="/TweenMax.min.js"></script>
<script>

	window.onerror = function () {
		alert(JSON.stringify(arguments, null, '\t'));
	};
	game();

	function game() {
		var socket = io();
		var circles = [];
		var unconfirmedCircles = {};
		var color;
		socket.on('color', function (c) {
			color = c;
		});
		var renderer = PIXI.autoDetectRenderer(window.innerWidth, window.innerHeight, {
			backgroundColor: 0x000000,
			antialias: true
		});
		document.body.appendChild(renderer.view);
		$(window).resize(function () {
			renderer.resize(window.innerWidth, window.innerHeight);
			circles.forEach(function (c) {
				stage.removeChild(c.sprite);
				c.sprite = generateSpriteForCircle(c);
				stage.addChild(c.sprite);
			});
		});
		var stage = new PIXI.Container();
		stage.addChild(getInteraction());
		var touchSprite = new PIXI.Sprite(PIXI.Texture.fromImage('touch.png'));
		touchSprite.anchor.x = 0.5;
		touchSprite.anchor.y = 0.5;
		touchSprite.position.x = renderer.view.width / 2;
		touchSprite.position.y = renderer.view.height / 2;
		touchSprite.alpha = 0.5;
		touchSprite.tl = new TimelineMax({repeat: -1})
				.to(touchSprite, 0.4, {alpha: 1, ease:Power1.easeOut}).
				to(touchSprite, 0.4, {alpha: 0.5, ease:Power1.easeIn});
		stage.addChild(touchSprite);

		function getInteraction() {
			var bg = new PIXI.Graphics();
			bg.interactive = true;
			bg.beginFill(0x000000);
			bg.drawRect(0, 0, 10000, 10000); //just make it big so we catch clicks no matter screen size
			bg.interactive = true;
			bg.on('click', onClick);
			bg.on('tap', onClick);
			return bg;


			function onClick(e) {
				if (touchSprite) {
					fadeSprite(stage, touchSprite);
					touchSprite = null;
				}
				var c = {
					id: Math.random() + '_' + Date.now(),
					x: e.data.global.x / renderer.view.width,
					y: e.data.global.y / renderer.view.height,
					size: 10/800
				};
				if(color){
					var uc = JSON.parse(JSON.stringify(c));
					uc.color = color;
					uc.sprite = generateSpriteForCircle(c);
					uc.sprite.alpha = 0.5;
					unconfirmedCircles[uc.id](uc);
					stage.addChild(uc.sprite);
				}
				socket.emit('click', c);
			}
		}

		function moveCirclesUp() {
			/*for (var i = 0; i < circles.length; i++) {
			 var c = circles[i];
			 c.y -= 1;
			 if (c.y < -c.height / 2) {
			 console.log('delete circle %d', i);
			 delete circles[i];
			 stage.removeChild(c.sprite);
			 }
			 }
			 circles = circles.filter(Boolean);*/
		}

		function generateSpriteForCircle(c) {
			var gfx = new PIXI.Graphics();
			gfx.beginFill(c.color);
			gfx.drawEllipse(0, 0, c.size * renderer.view.width, c.size * renderer.view.height);
			var sprite = new PIXI.Sprite(gfx.generateTexture());
			// center the sprite's anchor point
			sprite.anchor.x = 0.5;
			sprite.anchor.y = 0.5;
			sprite.position.x = c.x * renderer.view.width;
			sprite.position.y = c.y * renderer.view.height;
			return sprite;
		}

		socket.on('click', function (c) {
			console.log(c);
			c.sprite = generateSpriteForCircle(c);
			stage.addChild(c.sprite);
			circles.push(c);
			var uc = unconfirmedCircles[c.id];
			if(uc){
				stage.removeChild(uc.sprite);
				delete unconfirmedCircles[c.id]
			}
		});
		// start animating
		animate();
		function animate() {
			requestAnimationFrame(animate);
			// render the container
			for (var i = 0; i < circles.length - 1; i++) {
				for (var j = i + 1; j < circles.length; j++) {
					var c1 = circles[i];
					var c2 = circles[j];
					if (!c1 || !c2 || c1.color === c2.color) {
						continue;
					}
					var distance = Math.sqrt(
							Math.pow(Math.abs(c1.x - c2.x), 2) +
							Math.pow(Math.abs(c1.y - c2.y), 2)
					);
					var minDistance = (c1.size + c2.size);
					if (distance < minDistance) {
						console.log(distance, minDistance, Math.pow(Math.abs(c1.x - c2.x), 2));
						killCircleSprite(stage, c1.sprite);
						killCircleSprite(stage, c2.sprite);
						delete circles[i];
						delete circles[j];
					}
				}
			}
			circles = circles.filter(Boolean);
			renderer.render(stage);
		}
	}
	function killCircleSprite(stage, sprite) {
		new TimelineMax({
			onComplete: function () {
				stage.removeChild(sprite);
			}
		}).to(sprite.scale, 0.5, {x: 0, y: 0});

	}
	function fadeSprite(stage, sprite) {
		new TimelineMax({
			onComplete: function () {
				stage.removeChild(sprite);
				if(sprite.tl){
					sprite.tl.pause();
				}
			}
		}).to(sprite, 0.3, {alpha: 0});

	}
</script>
</body>
</html>