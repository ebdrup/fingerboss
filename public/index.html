<!doctype html>
<html>
<head>
	<title>fingerboss</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			background-color: #000000;
		}
	</style>
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black">
	<meta name="apple-mobile-web-app-title" content="Fingerboss">
	<meta name="viewport"
	      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">
	<meta name="viewport" content="minimal-ui">
</head>
<body>
<script src="/pixi.js"></script>
<script src="/socket.io-1.2.0.js"></script>
<script src="/jquery-1.11.1.js"></script>
<script src="/TweenMax.min.js"></script>
<script src="/howler.min.js"></script>
<script>

	window.onerror = function () {
		alert(JSON.stringify(arguments, null, '\t'));
	};
	game();

	function game() {
		var START_SIZE = 170 / 800;
		var KILL_SIZE = 5 / 800;
		var MIN_SIZE = START_SIZE + KILL_SIZE + 1 / 800;
		var END_SIZE = 700 / 800;
		var GROW_TIME = 6;
		var GROWING_ALPHA = 0.6;
		var UNCONFIRMED_ALPHA = 0.8;
		var CONFIRMED_SIZE_FACTOR = 1 / 5;
		var SOUND = true;
		var failSound = new Howl({
			urls: ['fail.mp3'],
			volume: 0.3
		});
		var successSound = new Howl({
			urls: ['success.mp3'],
			volume: 0.3
		});
		var socket = io();
		var circles = [];
		var unconfirmedCircles = {};
		var newCircle;
		var color, dt, velocity, textures = {}, scores = {};
		socket.on('start', function (e) {
			color = e.color;
			dt = Date.now() - e.t;
			velocity = e.velocity;
		});
		var renderer = PIXI.autoDetectRenderer(window.innerWidth, window.innerHeight, {
			backgroundColor: 0x000000,
			antialias: true
		});
		document.body.appendChild(renderer.view);
		$(window).resize(function () {
			renderer.resize(window.innerWidth, window.innerHeight);
			bg.width = renderer.view.width;
			bg.height = renderer.view.height;
			circles.forEach(function (c) {
				stage.removeChild(c.sprite);
				c.sprite = generateSpriteForCircle(c);
				stage.addChild(c.sprite);
			});
		});
		var stage = new PIXI.Container();
		var bg = getInteraction();
		stage.addChild(bg);
		var touchSprite = new PIXI.Sprite(PIXI.Texture.fromImage('touch.png'));
		touchSprite.anchor.x = 0.5;
		touchSprite.anchor.y = 0.5;
		touchSprite.position.x = renderer.view.width / 2;
		touchSprite.position.y = renderer.view.height / 2;
		touchSprite.alpha = 0.5;
		touchSprite.tl = new TimelineMax({repeat: -1})
				.to(touchSprite, 0.4, {alpha: 1, ease: Power1.easeOut}).
				to(touchSprite, 0.4, {alpha: 0.5, ease: Power1.easeIn});
		stage.addChild(touchSprite);

		function getInteraction() {
			var gfx = new PIXI.Graphics();
			gfx.beginFill(0x000000);
			gfx.drawRect(0, 0, 1, 1);
			var sprite = new PIXI.Sprite(gfx.generateTexture());
			// center the sprite's anchor point
			sprite.width = renderer.view.width;
			sprite.height = renderer.view.height;
			sprite.interactive = true;
			sprite.on('mousedown', onDown);
			sprite.on('touchstart', onDown);
			sprite.on('mousemove', onMove);
			sprite.on('touchmove', onMove);
			sprite.on('mouseup', onUp);
			sprite.on('touchend', onUp);
			return sprite;

			function onDown(e) {
				if (newCircle || !color) {
					return;
				}
				if (touchSprite) {
					fadeSprite(stage, touchSprite);
					touchSprite = null;
				}
				newCircle = {
					id: Math.random() + '_' + Date.now(),
					x: getX(e),
					y: getY(e),
					size: START_SIZE,
					color: color
				};
				newCircle.tl = new TimelineMax()
						.to(newCircle, GROW_TIME, {size: END_SIZE, ease: Power1.easeOut})
				newCircle.sprite = generateSpriteForCircle(newCircle);
				newCircle.sprite.alpha = GROWING_ALPHA;
				stage.addChild(newCircle.sprite);
			}

			function getX(e) {
				return Math.min(Math.max(e.data.global.x / renderer.view.width, 0), 1);
			}

			function getY(e) {
				return Math.min(Math.max(e.data.global.y / renderer.view.height, 0), 1);
			}

			function onMove(e) {
				if (newCircle) {
					newCircle.x = getX(e);
					newCircle.y = getY(e);
				}
			}

			function onUp(e) {
				if (newCircle) {
					newCircle.tl.kill();
					delete newCircle.tl;
					delete newCircle._gsTweenID;
					stage.removeChild(newCircle.sprite);
					delete newCircle.sprite;
					if (newCircle.size > MIN_SIZE) {
						newCircle.size -= START_SIZE;
						newCircle.size *= CONFIRMED_SIZE_FACTOR;
						socket.emit('circle', newCircle);
						newCircle.sprite = generateSpriteForCircle(newCircle);
						newCircle.sprite.alpha = UNCONFIRMED_ALPHA;
						unconfirmedCircles[newCircle.id] = newCircle;
						stage.addChild(newCircle.sprite)
					} else {
						SOUND && failSound.play();
					}
					newCircle = null;
				}
			}
		}

		function generateSpriteForCircle(c) {
			var w = renderer.view.width, h = renderer.view.height;
			var key = w + '_' + h + '_' + c.color;
			var texture = textures[key];
			if (!texture) {
				var gfx = new PIXI.Graphics();
				gfx.beginFill(c.color);
				gfx.drawEllipse(0, 0, 0.1 * w, 0.1 * h);
				textures[key] = texture = gfx.generateTexture();
			}
			var sprite = new PIXI.Sprite(texture);
			// center the sprite's anchor point
			sprite.anchor.x = 0.5;
			sprite.anchor.y = 0.5;
			sprite.position.x = c.x * renderer.view.width;
			sprite.position.y = c.y * renderer.view.height;
			sprite.width = c.size * renderer.view.width;
			sprite.height = c.size * renderer.view.height;
			return sprite;
		}

		socket.on('circle', function (c) {
			var proposed_dt = Date.now() - c.t;
			var dtDifference = proposed_dt - dt;
			if (Math.abs(dtDifference) > 200) {
				dt += 20 * (dtDifference / Math.abs(dtDifference)); //adjust dt a little
			}
			SOUND && successSound.play();
			c.sprite = generateSpriteForCircle(c);
			stage.addChild(c.sprite);
			circles.push(c);
			var uc = unconfirmedCircles[c.id];
			if (uc) {
				stage.removeChild(uc.sprite);
				delete unconfirmedCircles[c.id]
			}
			//collision detection
			var indexesToRemove = [];
			for (var i = 0; i < circles.length - 1; i++) {
				var c1 = circles[i];
				if (!c1 || !c || c1.color === c.color) {
					continue;
				}
				var distance = Math.sqrt(
						Math.pow(Math.abs(c1.x - c.x), 2) +
						Math.pow(Math.abs(getMovedCircleY(c1, c.t) - getMovedCircleY(c, c.t)), 2)
				);
				var minDistance = (c1.size + c.size);
				if (distance < minDistance) {
					var cSize = c.size;
					c.size -= c1.size;
					c1.size -= cSize;
					if (c1.size <= KILL_SIZE) {
						indexesToRemove.push(i);
						killCircleSprite(stage, c1.sprite);
					}
					if (c.size <= KILL_SIZE) {
						circles.pop(); // remove c
						killCircleSprite(stage, c.sprite);
						break;
					}
				}
			}
			indexesToRemove.forEach(function (i) {
				var c1 = circles[i];
				scores[c1.color] = scores[c1.color] || {value: 0};
				scores[c1.color].value -= (c1.unverifiedScore || 0); //remove scores added but not supposed to be
				delete circles[i];
			});
			circles = circles.filter(Boolean);
			//remove circles out of frame
			circles.forEach(function (c1, i) {
				var y = getMovedCircleY(c1, c.t);
				if (y < -c1.size || y > 1 + c1.size) {
					scores[c1.color] = scores[c1.color] || {value: 0};
					scores[c1.color].value += c1.size - (c1.unverifiedScore || 0);
					delete circles[i];
					stage.removeChild(c1.sprite);
				}
			});
			circles = circles.filter(Boolean);

		});
		function getMovedCircleY(c, t) {
			var dt = c.t - t;
			return c.y > 0.5 ? c.y + dt * velocity : c.y - dt * velocity;
		}

		// start animating
		animate();
		function animate() {
			requestAnimationFrame(animate);
			var t = Date.now() - dt / 2;
			circles.forEach(function (c1) {
				var y = getMovedCircleY(c1, t);
				c1.sprite.position.y = y * renderer.view.height;
				var expectedWidth = c1.size * renderer.view.width;
				var expectedHeight = c1.size * renderer.view.height;
				if (!c1.sprite.tl && (expectedWidth !== c1.sprite.width || expectedHeight !== c1.sprite.height)) {
					//resize sprite
					c1.sprite.tl = new TimelineMax({
						onComplete: function () {
							if(c1.sprite.tl){
								c1.sprite.tl.kill();
								delete c1.sprite.tl;
							}
						}
					}).to(c1.sprite, 0.3, {width: expectedWidth, height: expectedHeight});
				}
			});
			if (newCircle) {
				newCircle.sprite.position.x = newCircle.x * renderer.view.width;
				newCircle.sprite.position.y = newCircle.y * renderer.view.height;
				newCircle.sprite.width = newCircle.size * renderer.view.width;
				newCircle.sprite.height = newCircle.size * renderer.view.height;
				newCircle.sprite.alpha = newCircle.size > MIN_SIZE ? UNCONFIRMED_ALPHA : GROWING_ALPHA;
			}
			//score circles out of frame (unverified by server, they might get killed
			circles.forEach(function (c1, i) {
				var y = getMovedCircleY(c1, t);
				if (!c1.unverifiedScore && (y < -c1.size || y > 1 + c1.size)) {
					scores[c1.color] = scores[c1.color] || {value: 0};
					scores[c1.color].value += c1.size;
					c1.unverifiedScore = c1.size;
				}
			});
			// scores
			Object.keys(scores).forEach(function (key, i) {
				var color = '#' + parseInt(key, 10).toString(16);
				var s = scores[key];
				var score = Math.ceil(s.value * 800);
				var fontSize = Math.max(Math.ceil(renderer.view.height * 0.075), 30);
				var hash = score + '_' + fontSize;
				var style = {font: fontSize + "px Arial", fill: color};
				if (s.text) {
					if(s.hash != hash) {
						s.text.setText(score + '');
						s.text.style = style;
					}
				} else {
					s.text = new PIXI.Text(score + '', style);
					stage.addChild(s.text);
				}
				s.text.position.y = 10 + Math.round((i * fontSize * 1.1));
				s.text.position.x = 10;
			});
			// render the container
			renderer.render(stage);
		}
	}
	function killCircleSprite(stage, sprite) {
		if (sprite.tl) {
			sprite.tl.kill();
			delete sprite.tl;
		}
		sprite.tl = new TimelineMax({
			onComplete: function () {
				stage.removeChild(sprite);
				if (sprite.tl) {
					sprite.tl.kill();
					delete sprite.tl;
				}
			}
		}).to(sprite.scale, 0.5, {x: 0, y: 0});

	}
	function fadeSprite(stage, sprite) {
		new TimelineMax({
			onComplete: function () {
				stage.removeChild(sprite);
				if (sprite.tl) {
					sprite.tl.kill();
					delete sprite.tl;
				}
			}
		}).to(sprite, 0.3, {alpha: 0});
	}
</script>
</body>
</html>